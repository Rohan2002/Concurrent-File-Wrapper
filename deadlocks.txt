Two threads (A,B) and two mutexes(X, Y)

t_a             t_b

locks X         
                locks Y
locks Y         
unlocks Y
unlocks X


deadlock is not resolvalbe at run-time
deadlock is not detectable at run-time

deadlock conditions (coming on the exam)

1. mutex
    it must be possible to have exclusive access to some resource.
2. hold and wait.
    it must be possible to block while holding exclusive access.
3. no pre-emption
    only the thread holiding a lock can release it.
4. circular wait.
    e.g.g X waits for Y, while Y waits for X.


How can we fix this?
- be careful
- always acquire multiple resources in order
- dont use mutex
    - alternatives to mutex (transactional memory)
- prove that deadlock cannot occur.
- detect deadlock
circular wait with directory pool.


Semaphores

binary semaphore,
counting semaphore

both are synchronized integer

counting sempahore is always non-negative
binary semaphore is 0 or 1

create / init
sets the initial number for the semaphore

V / post / increase / signal / sem_post
    increases the number of the semaphore

P / wait / decrease
    if semaphore is 0 waits until another thread posts
    decreases the number never below 0.

Mutexes are restricted semaphore
    init is 1
    mutex_lock is sem_wait
    mutex_unlock is sem_post

condition varialbels are restricted semaphores
    init is 0
    cond_wait is sem_wait
    cond_signal is sem_post.

In a synchronized queue we can have
    1 semaphire counting open space in the queue.
    1 semaphore counting available data in the queue.

init 
------
lock(1)
data.init(0) 
free.init() // n spaces available


dequueue:
data.wait()
lock.wait()
remove the data queue
lock.post()
free.post()

queue_enqueue:
free.wait()
lock.wait()
add data
lock.post()
data.post()

cross processes semaphore exist.